exports.id=537,exports.ids=[537],exports.modules={9804:(e,t,i)=>{i.d(t,{PatchDetailsWebviewProvider:()=>PatchDetailsWebviewProvider});var s=i(9496),a=i(5255),o=i(9558),r=i(439),n=i(7881),h=i(4321),c=i(3646),l=i(847),d=i(2509);async function p(e,t,i){if(null==i)return;let a=await (0,l.C_)(i,{});if(0===a.length)return;let o=s.window.createQuickPick();o.ignoreFocusOut=(0,d.hE)();let r=[];try{let i=await new Promise(i=>{r.push(o.onDidHide(()=>i(void 0)),o.onDidAccept(()=>{0!==o.activeItems.length&&i(o.activeItems[0])})),o.title=e,o.placeholder=t,o.matchOnDescription=!0,o.matchOnDetail=!0,o.items=a,o.show()});if(null==i)return;return i}finally{o.dispose(),r.forEach(e=>void e.dispose())}}async function f(e,t,i){let a;let o=s.window.createInputBox();o.ignoreFocusOut=!0;let r=[];try{a=await new Promise(i=>{r.push(o.onDidHide(()=>i(void 0)),o.onDidAccept(()=>{let e=o.value.trim();if(null==e){o.validationMessage="Please enter a valid branch name";return}i(e)})),o.title=e,o.placeholder=t,o.prompt="Enter a name for the new branch",o.show()})}finally{o.dispose(),r.forEach(e=>void e.dispose())}return a}async function u(e,t){if(null==t)return;let i={label:"Create new branch",description:"Creates a branch to apply the Cloud Patch to. (Typing an existing branch name will use that branch.)"},a={label:"Select existing branch",description:"Selects an existing branch to apply the Cloud Patch to."},o=[i,a],r=s.window.createQuickPick();r.ignoreFocusOut=(0,d.hE)();let n=[];try{let s=await new Promise(t=>{n.push(r.onDidHide(()=>t(void 0)),r.onDidAccept(()=>{0!==r.activeItems.length&&t(r.activeItems[0])})),r.title=e,r.placeholder="Select a branch option",r.matchOnDescription=!0,r.matchOnDetail=!0,r.items=o,r.show()});if(s===i)return f(e,"Enter a name for the new branch",t);if(s===a)return p(e,"Select an existing branch",t);return}finally{r.dispose(),n.forEach(e=>void e.dispose())}}var g=i(9529),y=i(5148),m=i(2061),w=i(4241),v=i(9796),C=i(3105),D=i(3700),b=i(7387),x=i(5798),k=i(9679),_=i(4435);let P=new x.ke("patch/apply"),S=new x.ke("patch/create"),R=new x.ke("patch/openInGraph"),F=new x.ke("patch/checked");new x.ke("patch/selectRepo"),new x.ke("patch/selectBase"),new x.ke("patch/file/actions");let E=new x.ke("patch/file/open");new x.ke("patch/file/openOnRemote");let I=new x.ke("patch/file/compareWorking"),W=new x.ke("patch/file/comparePrevious"),M=new x.ke("patch/explain"),T=new x.ke("patch/preferences/update"),O=new x.ke("patch/switchMode"),q=new x.ke("patch/cloud/copyLink");new x.ke("patch/local/createPatch");let V=new x.ke("patch/create/repository/check"),A=new x.ke("patch/update/create/metadata"),H=new x.jH("patch/didChange",!0),U=new x.jH("patch/create/didChange"),$=new x.jH("patch/draft/didChange"),L=new x.jH("patch/preferences/didChange"),N=new x.jH("patch/didExplain"),j=new x.jH("patch/draft/didChangeRepository");let RepositoryRefChangeset=class RepositoryRefChangeset{constructor(e,t,i,s,a,o){this.container=e,this.repository=t,this.revision=i,this.files=s,this.checked=a,this.expanded=o}type="revision";dispose(){}suspend(){}resume(){}_checked=!1;get checked(){return this._checked}set checked(e){this._checked=e}_expanded=!1;get expanded(){return this._expanded}set expanded(e){this._expanded!==e&&(this._expanded=e)}async getChange(){return{type:"revision",repository:{name:this.repository.name,path:this.repository.path,uri:this.repository.uri.toString()},revision:this.revision,files:this.files,checked:this.checked,expanded:this.expanded}}};let RepositoryWipChangeset=class RepositoryWipChangeset{constructor(e,t,i,s,a,o){this.container=e,this.repository=t,this.revision=i,this.onDidChangeRepositoryWip=s,this.checked=a,this.expanded=o}type="wip";_disposable;dispose(){this._disposable?.dispose(),this._disposable=void 0}suspend(){this._disposable?.dispose(),this._disposable=void 0}resume(){this._files=void 0,this._expanded&&this.subscribe()}_checked=!1;get checked(){return this._checked}set checked(e){this._checked=e}_expanded=!1;get expanded(){return this._expanded}set expanded(e){this._expanded!==e&&(this._files=void 0,e?this.subscribe():(this._disposable?.dispose(),this._disposable=void 0),this._expanded=e)}_files;async getChange(){let e;return this.expanded&&(null==this._files&&(this._files=this.getFiles()),e=await this._files),{type:"wip",repository:{name:this.repository.name,path:this.repository.path,uri:this.repository.uri.toString()},revision:this.revision,files:e?.files,checked:this.checked,expanded:this.expanded}}subscribe(){null==this._disposable&&(this._disposable=s.Disposable.from(this.repository.watchFileSystem(1e3),this.repository.onDidChangeFileSystem(()=>this.onDidChangeWip(),this),this.repository.onDidChange(e=>{e.changed(c.I6.Index,c.du.Any)&&this.onDidChangeWip()})))}onDidChangeWip(){this._files=void 0,this.onDidChangeRepositoryWip(this)}async getFiles(){let e=await this.container.git.getStatusForRepo(this.repository.path),t=[];if(null!=e)for(let i of e.files){let e={repoPath:i.repoPath,path:i.path,status:i.status,originalPath:i.originalPath,staged:i.staged};t.push(e),i.staged&&i.wip&&t.push({...e,staged:!1})}return{files:t}}};var G=Object.defineProperty,B=Object.getOwnPropertyDescriptor;let PatchDetailsWebviewProvider=class PatchDetailsWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._context={mode:"create",draft:void 0,create:void 0,preferences:this.getPreferences()},this.setHostTitle(),this.host.description="PREVIEW ☁️",this._disposable=s.Disposable.from(y.D.onDidChangeAny(this.onAnyConfigurationChanged,this),e.git.onDidChangeRepositories(this.onRepositoriesChanged,this))}_context;_disposable;dispose(){this._disposable.dispose()}canReuseInstance(...e){let[t]=e;if(t?.mode==="view"&&null!=t.draft)switch(t.draft.draftType){case"cloud":return this._context.draft?.draftType===t.draft.draftType&&this._context.draft.id===t.draft.id;case"local":return this._context.draft?.draftType===t.draft.draftType&&this._context.draft.patch.contents===t.draft.patch?.contents}return!1}async onShowing(e,t,...i){let[s]=i;if(s?.mode==="view"&&null!=s.draft)this.updateViewDraftState(s.draft);else{this.container.git.isDiscoveringRepositories&&await this.container.git.isDiscoveringRepositories;let e=s?.mode==="create"&&null!=s.create?s.create:{repositories:void 0};this.updateCreateDraftState(e)}return!t?.preserveVisibility||!!this.host.visible}includeBootstrap(){return this.getState(this._context)}registerCommands(){return this.host.isView()?[(0,g.xR)(`${this.host.id}.refresh`,()=>this.host.refresh(!0)),(0,g.xR)(`${this.host.id}.close`,()=>this.closeView())]:[]}onMessageReceived(e){switch(e.method){case P.method:(0,x.mq)(P,e,e=>this.applyPatch(e));break;case q.method:(0,x.mq)(q,e,()=>this.copyCloudLink());break;case S.method:(0,x.mq)(S,e,e=>this.createDraft(e));break;case M.method:(0,x.mq)(M,e,()=>this.explainPatch(e.completionId));break;case W.method:(0,x.mq)(W,e,e=>void this.openFileComparisonWithPrevious(e));break;case I.method:(0,x.mq)(I,e,e=>void this.openFileComparisonWithWorking(e));break;case E.method:(0,x.mq)(E,e,e=>void this.openFile(e));break;case R.method:(0,x.mq)(R,e,e=>void(0,g.P0)(a.Gh.ShowInCommitGraph,{ref:(0,h.xB)(e.ref,e.repoPath,{refType:"revision"})}));break;case O.method:(0,x.mq)(O,e,e=>this.switchMode(e));break;case A.method:(0,x.mq)(A,e,e=>this.updateCreateMetadata(e));break;case V.method:(0,x.mq)(V,e,e=>this.updateCreateCheckedState(e));break;case T.method:(0,x.mq)(T,e,e=>this.updatePreferences(e));break;case F.method:(0,x.mq)(F,e,e=>this.onPatchChecked(e))}}onRefresh(){this.updateState(!0)}onReloaded(){this.updateState(!0)}onVisibilityChanged(e){this._context.create?.changes.forEach(t=>e?t.resume():t.suspend()),e&&this.host.sendPendingIpcNotifications()}onAnyConfigurationChanged(e){(y.D.changed(e,["defaultDateFormat","views.patchDetails.files","views.patchDetails.avatars"])||y.D.changedCore(e,"workbench.tree.renderIndentGuides")||y.D.changedCore(e,"workbench.tree.indent"))&&(this._context.preferences={...this._context.preferences,...this.getPreferences()},this.updateState())}getPreferences(){return{avatars:y.D.get("views.patchDetails.avatars"),dateFormat:y.D.get("defaultDateFormat")??"MMMM Do, YYYY h:mma",files:y.D.get("views.patchDetails.files"),indentGuides:y.D.getCore("workbench.tree.renderIndentGuides")??"onHover",indent:y.D.getCore("workbench.tree.indent")}}onRepositoriesChanged(e){if("create"===this.mode&&null!=this._context.create){if(this._context.create?.showingAllRepos)for(let t of e.added)this._context.create.changes.set(t.uri.toString(),new RepositoryWipChangeset(this.container,t,{to:r.CL,from:"HEAD"},this.onRepositoryWipChanged.bind(this),!1,!0));for(let t of e.removed)this._context.create.changes.delete(t.uri.toString());this.notifyDidChangeCreateDraftState()}}onRepositoryWipChanged(e){this.notifyDidChangeCreateDraftState()}get mode(){return this._context.mode}setMode(e,t){this._context.mode=e,this.setHostTitle(e),(0,m.v)("gitlens:views:patchDetails:mode","editor"===y.D.get("cloudPatches.experimental.layout")?void 0:e),t||this.updateState(!0)}setHostTitle(e=this._context.mode){this.host.title="create"===e?"Create Cloud Patch":"Cloud Patch Details"}async applyPatch(e){if(null==this._context.draft||"local"===this._context.draft.draftType||!e.selected?.length)return;let t=this._context.draft.changesets?.[0];if(null==t)return;let i="branch"===e.target;for(let o of t.patches)if(e.selected.includes(o.id))try{let e;console.log(o);let t=o.commit;if(t||(t=await this.getOrCreateCommitForPatch(o.gkRepositoryId)),!t)continue;if(i){let i=t.getRepository(),r=await u(`Choose a Branch ${a.NE.Dot} ${i?.name}`,i);if(null==r){s.window.showErrorMessage(`Unable apply patch to '${o.repository.name}': No branch selected`);continue}let n="string"==typeof r;e={branchName:n?r:r.ref,createBranchIfNeeded:n}}this.container.git.applyUnreachableCommitForPatch(t.repoPath,t.ref,e)}catch(e){s.window.showErrorMessage(`Unable apply patch to '${o.baseRef}': ${e.message}`)}}closeView(){(0,m.v)("gitlens:views:patchDetails:mode",void 0)}copyCloudLink(){this._context.draft?.draftType==="cloud"&&s.env.clipboard.writeText(this._context.draft.deepLinkUrl)}async createDraft({title:e,changesets:t,description:i,visibility:a}){if(!await (0,_.wz)("Cloud Patches require a GitKraken account.",this.container)||!await (0,_.FQ)(this.container))return;let o=[],n=Object.entries(t),h=1===n.length;for(let[e,t]of n){if(!h&&!1===t.checked)continue;let i=this._context.create?.changes?.get(e);if(null==i)continue;let{revision:s,repository:a}=i;"wip"===t.type&&"staged"===t.checked&&(s={...s,to:r.pw}),o.push({repository:a,revision:s})}if(null!=o)try{let t=await this.container.drafts.createDraft("patch",e,o,{description:i,visibility:a});(async function(){let e={title:"View Patch"},i={title:"Copy Link"},a=!1;for(;;){let o=await s.window.showInformationMessage(`Cloud Patch successfully created${a?"— link copied to the clipboard":""}`,e,i);if(o===i){s.env.clipboard.writeText(t.deepLinkUrl),a=!0;continue}o===e&&(0,k.l)({mode:"view",draft:t});break}})(),this.container.draftsView.refresh(!0).then(()=>void this.container.draftsView.revealDraft(t)),this.closeView()}catch(e){s.window.showErrorMessage(`Unable to create draft: ${e.message}`)}}async explainPatch(e){let t;if(this._context.draft?.draftType==="cloud"){try{let e=await this.getDraftPatch(this._context.draft);if(null==e)throw Error("Unable to find patch");let i=await this.getOrCreateCommitForPatch(e.gkRepositoryId);if(null==i)throw Error("Unable to find commit");let s=await this.container.ai.explainCommit(i,{progress:{location:{viewId:this.host.id}}});if(null==s)throw Error("Error retrieving content");t={summary:s}}catch(e){t={error:{message:e.message}}}this.host.notify(N,t,e)}}async openPatchContents(e){}async onPatchChecked(e){if(e.patch.repository.located||!1===e.checked)return;let t=this._context.draft?.changesets?.[0].patches?.find(t=>t.gkRepositoryId===e.patch.gkRepositoryId);if(t?.repository==null||(0,c.uC)(t.repository))return;let i=await this.container.repositoryIdentity.getRepository(t.repository,{openIfNeeded:!0,prompt:!0});null==i?s.window.showErrorMessage(`Unable to locate repository '${t.repository.name}'`):t.repository=i,this.notifyPatchRepositoryUpdated(t)}notifyPatchRepositoryUpdated(e){return this.host.notify(j,{patch:(0,b.q)({...e,contents:void 0,commit:void 0,repository:{id:e.gkRepositoryId,name:e.repository?.name??"",located:null!=e.repository&&(0,c.uC)(e.repository)}})})}updateCreateCheckedState(e){let t=this._context.create?.changes.get(e.repoUri);null!=t&&(t.checked=e.checked,this.notifyDidChangeCreateDraftState())}updateCreateMetadata(e){null!=this._context.create&&(this._context.create.title=e.title,this._context.create.description=e.description,this._context.create.visibility=e.visibility,this.notifyDidChangeCreateDraftState())}switchMode(e){this.setMode(e.mode)}_notifyDidChangeStateDebounced=void 0;updateState(e=!1){if(this.host.clearPendingIpcNotifications(),e){this.notifyDidChangeState();return}null==this._notifyDidChangeStateDebounced&&(this._notifyDidChangeStateDebounced=(0,v.Ds)(this.notifyDidChangeState.bind(this),500)),this._notifyDidChangeStateDebounced()}async getState(e){let t,i;return"create"===e.mode&&null!=e.create&&(t=await this.getCreateDraftState(e)),"view"===e.mode&&null!=e.draft&&(i=await this.getViewDraftState(e)),(0,b.q)({...this.host.baseWebviewState,mode:e.mode,create:t,draft:i,preferences:e.preferences})}async notifyDidChangeState(){return this._notifyDidChangeStateDebounced?.cancel(),this.host.notify(H,{state:await this.getState(this._context)})}updateCreateDraftState(e){let t;let i=!1;if(null!=e.changes){t=this._context.create?.changes??new Map;let i=new Set;for(let a of e.changes){let e;let o=this.container.git.getRepository(s.Uri.parse(a.repository.uri));null!=o&&(e="wip"===a.type?new RepositoryWipChangeset(this.container,o,a.revision,this.onRepositoryWipChanged.bind(this),a.checked??!0,a.expanded??!0):new RepositoryRefChangeset(this.container,o,a.revision,a.files,a.checked??!0,a.expanded??!0),i.add(o.uri.toString()),t.set(o.uri.toString(),e))}if(i.size!==t.size)for(let[e,s]of t)i.has(e)||(s.checked=!1)}else{i=null==e.repositories;let s=e.repositories??this.container.git.openRepositories;t=new Map(s.map(e=>[e.uri.toString(),new RepositoryWipChangeset(this.container,e,{to:r.CL,from:"HEAD"},this.onRepositoryWipChanged.bind(this),!0,!0)]))}this._context.create={title:e.title,description:e.description,changes:t,showingAllRepos:i,visibility:"public"},this.setMode("create",!0),this.notifyDidChangeCreateDraftState()}async getCreateDraftState(e){let{create:t}=e;if(null==t)return;let i={};if(0!==t.changes.size)for(let[e,s]of t.changes){let t=await s.getChange();t?.files?.length!==0&&(t.checked!==s.checked&&(t.checked=s.checked),i[e]=t)}return{title:t.title,description:t.description,changes:i,visibility:t.visibility}}async notifyDidChangeCreateDraftState(){return this.host.notify(U,{mode:this._context.mode,create:await this.getCreateDraftState(this._context)})}updateViewDraftState(e){this._context.draft=e,this.setMode("view",!0),this.notifyDidChangeViewDraftState()}async getViewDraftState(e){if(null==e.draft)return;let t=e.draft;if("cloud"===t.draftType)return(null==t.changesets||(0,C.G)(t.changesets,e=>e.patches.some(e=>null==e.contents||null==e.files||null==e.repository)))&&setTimeout(async()=>{null==t.changesets&&(t.changesets=await this.container.drafts.getChangesets(t.id));let e=t.changesets.flatMap(e=>e.patches).filter(e=>null==e.contents||null==e.files||null==e.repository);for(let t of(await Promise.allSettled(e.map(e=>this.container.drafts.getPatchDetails(e)))))if("fulfilled"===t.status){let i=e.find(e=>e.id===t.value.id);null!=i&&(i.contents=t.value.contents,i.files=t.value.files,i.repository=t.value.repository)}this.notifyDidChangeViewDraftState()},0),{draftType:"cloud",id:t.id,createdAt:t.createdAt.getTime(),updatedAt:t.updatedAt.getTime(),author:t.author,role:t.role,title:t.title,description:t.description,visibility:t.visibility,patches:(0,b.q)(t.changesets[0].patches.map(e=>({...e,contents:void 0,commit:void 0,repository:{id:e.gkRepositoryId,name:e.repository?.name??"",located:null!=e.repository&&(0,c.uC)(e.repository)}})))}}async notifyDidChangeViewDraftState(){return this.host.notify($,{mode:this._context.mode,draft:(0,b.q)(await this.getViewDraftState(this._context))})}updatePreferences(e){(this._context.preferences?.files?.compact!==e.files?.compact||this._context.preferences?.files?.icon!==e.files?.icon||this._context.preferences?.files?.layout!==e.files?.layout||this._context.preferences?.files?.threshold!==e.files?.threshold)&&(null!=e.files&&(this._context.preferences?.files?.compact!==e.files?.compact&&y.D.updateEffective("views.patchDetails.files.compact",e.files?.compact),this._context.preferences?.files?.icon!==e.files?.icon&&y.D.updateEffective("views.patchDetails.files.icon",e.files?.icon),this._context.preferences?.files?.layout!==e.files?.layout&&y.D.updateEffective("views.patchDetails.files.layout",e.files?.layout),this._context.preferences?.files?.threshold!==e.files?.threshold&&y.D.updateEffective("views.patchDetails.files.threshold",e.files?.threshold),this._context.preferences.files=e.files),this.notifyDidChangePreferences())}async notifyDidChangePreferences(){return this.host.notify(L,{preferences:this._context.preferences})}async getDraftPatch(e,t){if(null==e.changesets){let t=await this.container.drafts.getChangesets(e.id);e.changesets=t}let i=null==t?e.changesets[0].patches?.[0]:e.changesets[0].patches?.find(e=>e.gkRepositoryId===t);if(null!=i){if(null==i.contents||null==i.files||null==i.repository){let e=await this.container.drafts.getPatchDetails(i.id);i.contents=e.contents,i.files=e.files,i.repository=e.repository}return i}}async getFileCommitFromParams(e){let[t,i]=await this.getOrCreateCommit(e);return null!=t&&null!=i?[t,new n.K8(e.repoPath,e.path,e.status,e.originalPath,void 0,void 0,e.staged),i]:null!=(t=await t?.getCommitForFile(e.path,e.staged))?[t,t.file,i]:void 0}async getOrCreateCommit(e){switch(this.mode){case"create":return this.getCommitForFile(e);case"view":return[await this.getOrCreateCommitForPatch(e.gkRepositoryId)];default:return[void 0]}}async getCommitForFile(e){let t=(0,C.sE)(this._context.create.changes.values(),t=>t.repository.path===e.repoPath);if(null==t)return[void 0];let i=await t.getChange();if(null==i)return[void 0];if("revision"===i.type){let t=await this.container.git.getCommit(e.repoPath,i.revision.to??r.CL);return i.revision.to===i.revision.from||i.revision.from.length===i.revision.to.length+1&&i.revision.from.endsWith("^")&&i.revision.from.startsWith(i.revision.to)?[t]:[t,i.revision]}return"wip"===i.type?[await this.container.git.getCommit(e.repoPath,i.revision.to??r.CL)]:[void 0]}async getOrCreateCommitForPatch(e){let t=this._context.draft;if("local"===t.draftType)return;let i=await this.getDraftPatch(t,e);if(i?.repository!=null){if(i?.commit==null){if(!(0,c.uC)(i.repository)){let e=await this.container.repositoryIdentity.getRepository(i.repository,{openIfNeeded:!0,prompt:!0});if(null==e){s.window.showErrorMessage(`Unable to locate repository '${i.repository.name}'`);return}i.repository=e}try{let e=await this.container.git.createUnreachableCommitForPatch(i.repository.uri,i.contents,i.baseRef??"HEAD",t.title);i.commit=e}catch(e){s.window.showErrorMessage(`Unable preview the patch on base '${i.baseRef}': ${e.message}`),i.baseRef=void 0}}return i?.commit}}async openFile(e){let t=await this.getFileCommitFromParams(e);if(null==t)return;let[i,s]=t;(0,o.ZB)(s,i,{preserveFocus:!0,preview:!0,...e.showOptions})}async openFileComparisonWithPrevious(e){let t=await this.getFileCommitFromParams(e);if(null==t)return;let[i,s,a]=t;(0,o.vw)(s,null!=a?{repoPath:i.repoPath,rhs:a.to??r.CL,lhs:a.from}:i,{preserveFocus:!0,preview:!0,...e.showOptions,rhsTitle:"view"===this.mode?`${(0,D.EZ)(s.path)} (Patch)`:void 0}),this.container.events.fire("file:selected",{uri:s.uri},{source:this.host.id})}async openFileComparisonWithWorking(e){let t=await this.getFileCommitFromParams(e);if(null==t)return;let[i,s,a]=t;(0,o.ce)(s,null!=a?{repoPath:i.repoPath,ref:a.to}:i,{preserveFocus:!0,preview:!0,...e.showOptions,lhsTitle:"view"===this.mode?`${(0,D.EZ)(s.path)} (Patch)`:void 0})}};((e,t,i,s)=>{for(var a,o=s>1?void 0:s?B(t,i):t,r=e.length-1;r>=0;r--)(a=e[r])&&(o=(s?a(t,i,o):a(o))||o);return s&&o&&G(t,i,o)})([(0,w.fF)({args:!1})],PatchDetailsWebviewProvider.prototype,"getState",1)},7387:(e,t,i)=>{i.d(t,{q:()=>s});function s(e){if(null!=e)try{return JSON.parse(JSON.stringify(e,function(e,t){if(t instanceof Date)return t.getTime();if(t instanceof Map||t instanceof Set)return[...t.entries()];if(t instanceof Function||t instanceof Error)return;if(t instanceof RegExp)return t.toString();let i=this[e];return i instanceof Date?i.getTime():t}))}catch(e){throw e}}}};